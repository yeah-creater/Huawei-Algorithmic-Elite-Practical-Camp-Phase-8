## 内存调度



### 解法一 2024/6/17

> 未通过全部样例  
>
> 得分 10w +
>
> 错误点:  并没有考虑依赖关系



```c++
#include <bits/stdc++.h>


using namespace std;

int l, n, m, N, M;
// 定义任务结构体
struct Task {
    int id;
    int size_;
    int output_data_size;
    int free_cnt = 0;
    set<int> affinity_machines;
};

//优先选择的任务首先释放的子任务要多，其次是亲和机器要多 
struct CompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
        if (p1.free_cnt == p2.free_cnt){
        	return p1.affinity_machines.size() < p2.affinity_machines.size();
		}
		return p1.free_cnt < p2.free_cnt;
    }
};

// 定义机器结构体
struct Machine {
    int id;
    int power;
    int available_time = 0; // 机器的可用时间初始化为0
};
struct CompareMachine {
    bool operator()(const Machine& p1, const Machine& p2) { 
        return p1.power < p2.power;
    }
};

// 定义磁盘结构体
struct Disk {
    int id;
    int rate;
    int quota;
    int used_quota = 0; // 磁盘的已用配额初始化为0
    int available_time = 0; // 磁盘的可用时间初始化为0
};

// 优先选择存储能力强的 
struct CompareDisk {
    bool operator()(const Disk& p1, const Disk& p2) { 
        if (p1.rate == p2.rate) {
        	return p1.quota < p2.quota;
		}
		return p1.rate < p2.rate;
    }
};


// 定义依赖关系结构体
struct Dependency {
    int task_id;
    int dependency_type; // 0表示数据依赖，1表示环境依赖
};

int up(int a, int b) {
	return (a + b - 1 ) / a;
}

// 计算任务的开始时间
void work(vector<Task>& tasks, vector<Machine>& machines,
	vector<Disk>& disks,vector<pair<int, int>>& data_dependencies, vector<pair<int, int>>& environment_dependencies) {
    vector<vector<Dependency>> ps(l + 1, vector<Dependency>(0)); // 记录每个任务的依赖节点 
    vector<vector<Dependency>> sons(l + 1, vector<Dependency>(0)); 
    priority_queue<Task, vector<Task>, CompareTask> ready_tasks_pq;
	priority_queue<Machine, vector<Machine>, CompareMachine> machines_pq;
	priority_queue<Disk, vector<Disk>, CompareDisk> disks_pq;	
	vector<int> dus(l + 1, 0);
    vector<int> save_disk(l + 1, 0); // 记录每个任务存储在哪个disk 
	vector<int> pre_cost(l + 1, 0); // 记录每个任务需要预处理的时间 
	for (auto& item:data_dependencies){
    	ps[item.second].push_back({item.first, 0}); 
    	sons[item.first].push_back({item.second, 0});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	for (auto& item:environment_dependencies){
    	ps[item.second].push_back({item.first, 1});
    	sons[item.first].push_back({item.second, 1});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	//初始化就绪任务 
	for (int i = 1; i <= l; i ++){
		if (dus[i] == 0) {
			dus[i] = -1;
			ready_tasks_pq.push(tasks[i]);
		}
	}
	//初始化机器优先队列 
	for (int i = 1;i <= n; i ++){
		machines_pq.push(machines[i]);
	}
	//初始化硬盘优先队列 
	for (int i = 1;i <= m; i ++){
		disks_pq.push(disks[i]);
	}
		
	while (!ready_tasks_pq.empty()){
		auto deal_task = ready_tasks_pq.top();
		ready_tasks_pq.pop();
		int id = deal_task.id;
		// 记录需要花费的时间 先加上预处理的 
		int cost_time = pre_cost[id]; 
		vector<Machine> machines_tmp;
		vector<Disk> disks_tmp;
		while (! machines_pq.empty()){
			auto deal_machine = machines_pq.top();
			machines_pq.pop();
			machines_tmp.push_back(deal_machine);
			// 亲和度满足
			if (deal_task.affinity_machines.count(deal_machine.id)) {
				break;
			}
			
		}
		while (! disks_pq.empty()){
			auto deal_disk = disks_pq.top();
			disks_pq.pop();
			disks_tmp.push_back(deal_disk);
			//剩余额度满足
			if  (deal_disk.quota - deal_disk.used_quota >= deal_task.output_data_size) {
				break;
			}
			
		}
		int machines_idx = machines_tmp.size() - 1;
		int disks_idx = disks_tmp.size() - 1;
		auto &deal_machine = machines_tmp[machines_idx];
		auto &deal_disk = disks_tmp[disks_idx];		
		int arrival_time = max(deal_machine.available_time, deal_disk.available_time);
		
		cout << id << " " << arrival_time + cost_time << " " << deal_machine.id << " " <<  deal_disk.id << "\n";
		cost_time += up(deal_machine.power, deal_task.size_);
		cost_time += up(deal_disk.rate, deal_task.output_data_size);
		//使用的mahcine和disk更新参数
		deal_machine.available_time += cost_time;
		deal_disk.available_time += cost_time;
		deal_disk.used_quota += deal_task.output_data_size;
		
		//出队的machine和disk重新入队
		for (auto m:machines_tmp){
			machines_pq.push(m);
		} 

		for (auto d:disks_tmp){
			disks_pq.push(d);
		} 		
		
		//释放依赖并为其依赖加上读取时间(若必要的话) 
		for (auto &son:sons[id]){
			dus[son.task_id] -= 1;
			if (son.dependency_type == 0) {
				pre_cost[son.task_id] += up(deal_disk.rate, deal_task.output_data_size);
			}
			if (dus[son.task_id] == 0) {
				ready_tasks_pq.push(tasks[son.task_id]);
			}
		}
		
		
	}
	
	

}

int main() {
	
    
    cin >> l;
    vector<Task> tasks(l + 1);
    int id;
    // 读取任务信息
    for (int i = 1; i <= l; ++i) {
        int k;
        cin >> id;
        tasks[id].id = id;
        cin >> tasks[id].size_ >> tasks[id].output_data_size >> k;
        for (int j = 0; j < k; ++j) {
        	int x;
        	cin >> x;
            tasks[i].affinity_machines.insert(x);
        }
    }
    
    // 读取机器信息
    cin >> n;
    vector<Machine> machines(n + 1);
    
    for (int i = 1; i <= n; ++i) {
    	cin >> id;
    	machines[id].id = id;
        cin >> machines[id].power;
    }
    
    // 读取磁盘信息
    cin >> m;
    vector<Disk> disks(m + 1);
    
    for (int i = 1; i <= m; ++i) {
    	cin >> id;
    	disks[id].id = id;
        cin >> disks[i].rate >> disks[i].quota;
    }
    
    // 读取数据依赖信息
    cin >> N;
    vector<pair<int, int>> data_dependencies(N + 1);
    
    for (int i = 1; i <= N; ++i) {
        cin >> data_dependencies[i].first >> data_dependencies[i].second;
    }
    
    // 读取环境依赖信息
    cin >> M;
    vector<pair<int, int>> environment_dependencies(M + 1);
    
    for (int i = 1; i <= M; ++i) {
        cin >> environment_dependencies[i].first >> environment_dependencies[i].second;
    }

    // 计算任务的结束时间
//    vector<tuple<int, int, int, int, int>> results = 
	work(tasks, machines, disks, data_dependencies, environment_dependencies);

    // 输出任务的调度结果
//    for (const auto& result : results) {
//        int task_id, start_time, end_time, machine_id, disk_id;
//        tie(task_id, start_time, end_time, machine_id, disk_id) = result;
//        cout << task_id << " " << start_time << " " << machine_id << " " << disk_id << "\n";
//    }

    return 0;
}

```

### 解法二 2024/6/17

> 未通过全部样例
>
> 得分 17w +
>
> 错误点:  错误地更新了每次机器的开始时间

```c++
#include <bits/stdc++.h>


using namespace std;

int l, n, m, N, M;
// 定义任务结构体
struct Task {
    int id;
    int size_;
    int output_data_size;
    int free_cnt = 0;
    set<int> affinity_machines;
};

//优先选择的任务首先释放的子任务要多，其次是亲和机器要多 
struct CompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
        if (p1.free_cnt == p2.free_cnt){
        	return p1.affinity_machines.size() < p2.affinity_machines.size();
		}
		return p1.free_cnt < p2.free_cnt;
    }
};

// 定义机器结构体
struct Machine {
    int id;
    int power;
    int available_time = 0; // 机器的可用时间初始化为0
};
//优先选择的任务要尽早结束
struct CompareMachine {
    bool operator()(const Machine& p1, const Machine& p2) { 
        if (p1.available_time == p2.available_time){
            return p1.power < p2.power;
        }
        return p1.available_time > p2.available_time;
        
    }
};

// 定义磁盘结构体
struct Disk {
    int id;
    int rate;
    int quota;
    int used_quota = 0; // 磁盘的已用配额初始化为0
    int available_time = 0; // 磁盘的可用时间初始化为0
};

// 优先最早结束，其次优先选择存储能力强的 
struct CompareDisk {
    bool operator()(const Disk& p1, const Disk& p2) { 
        if (p1.available_time == p2.available_time){
            if (p1.rate == p2.rate) {
            	return p1.quota < p2.quota;
    		}
    		return p1.rate < p2.rate;
        }
        return p1.available_time > p2.available_time;
    }
};


// 定义依赖关系结构体
struct Dependency {
    int task_id;
    int dependency_type; // 0表示数据依赖，1表示环境依赖
};

int up(int a, int b) {
	return (a + b - 1 ) / a;
}

// 计算任务的开始时间
void work(vector<Task>& tasks, vector<Machine>& machines,
	vector<Disk>& disks,vector<pair<int, int>>& data_dependencies, vector<pair<int, int>>& environment_dependencies) {
    vector<vector<Dependency>> ps(l + 1, vector<Dependency>(0)); // 记录每个任务的依赖节点 
    vector<vector<Dependency>> sons(l + 1, vector<Dependency>(0)); 
    priority_queue<Task, vector<Task>, CompareTask> ready_tasks_pq;
	priority_queue<Machine, vector<Machine>, CompareMachine> machines_pq;
	priority_queue<Disk, vector<Disk>, CompareDisk> disks_pq;	
	vector<int> dus(l + 1, 0);
    vector<int> save_disk(l + 1, 0); // 记录每个任务存储在哪个disk 
	vector<int> pre_cost(l + 1, 0); // 记录每个任务需要预处理的时间 
	vector<int> start_time(l + 1, 0);
	for (auto& item:data_dependencies){
    	ps[item.second].push_back({item.first, 0}); 
    	sons[item.first].push_back({item.second, 0});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	for (auto& item:environment_dependencies){
    	ps[item.second].push_back({item.first, 1});
    	sons[item.first].push_back({item.second, 1});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	//初始化就绪任务 
	for (int i = 1; i <= l; i ++){
		if (dus[i] == 0) {
			dus[i] = -1;
			ready_tasks_pq.push(tasks[i]);
		}
	}
	//初始化机器优先队列 
	for (int i = 1;i <= n; i ++){
		machines_pq.push(machines[i]);
	}
	//初始化硬盘优先队列 
	for (int i = 1;i <= m; i ++){
		disks_pq.push(disks[i]);
	}
		
	while (!ready_tasks_pq.empty()){
		auto deal_task = ready_tasks_pq.top();
		ready_tasks_pq.pop();
		int id = deal_task.id;
		// 记录需要花费的时间 先加上预处理的 
		int cost_time = pre_cost[id]; 
		vector<Machine> machines_tmp;
		vector<Disk> disks_tmp;
		while (! machines_pq.empty()){
			auto deal_machine = machines_pq.top();
			machines_pq.pop();
			machines_tmp.push_back(deal_machine);
			// 亲和度满足
			if (deal_task.affinity_machines.count(deal_machine.id)) {
				break;
			}
			
		}
		while (! disks_pq.empty()){
			auto deal_disk = disks_pq.top();
			disks_pq.pop();
			disks_tmp.push_back(deal_disk);
			//剩余额度满足
			if  (deal_disk.quota - deal_disk.used_quota >= deal_task.output_data_size) {
				break;
			}
			
		}
		int machines_idx = machines_tmp.size() - 1;
		int disks_idx = disks_tmp.size() - 1;
		auto &deal_machine = machines_tmp[machines_idx];
		auto &deal_disk = disks_tmp[disks_idx];		
		int arrival_time = max(deal_machine.available_time, deal_disk.available_time);
		
		cout << id << " " << max(arrival_time, start_time[id]) << " " << deal_machine.id << " " <<  deal_disk.id << "\n";
		cost_time += up(deal_machine.power, deal_task.size_);
		cost_time += up(deal_disk.rate, deal_task.output_data_size);
		//使用的mahcine和disk更新参数
		deal_machine.available_time += cost_time;
		deal_disk.available_time += cost_time;
		deal_disk.used_quota += deal_task.output_data_size;
		
		//出队的machine和disk重新入队
		for (auto m:machines_tmp){
			machines_pq.push(m);
		} 

		for (auto d:disks_tmp){
			disks_pq.push(d);
		} 		
		
		//释放依赖并为其依赖加上读取时间(若必要的话) 
		for (auto &son:sons[id]){
			dus[son.task_id] -= 1;
			start_time[son.task_id] = max(start_time[son.task_id], arrival_time + cost_time);
			if (son.dependency_type == 0) {
				pre_cost[son.task_id] += up(deal_disk.rate, deal_task.output_data_size);
			}
			if (dus[son.task_id] == 0) {
				ready_tasks_pq.push(tasks[son.task_id]);
			}
		}
		
		
	}
	
	

}

int main() {
	
    
    cin >> l;
    vector<Task> tasks(l + 1);
    int id;
    // 读取任务信息
    for (int i = 1; i <= l; ++i) {
        int k;
        cin >> id;
        tasks[id].id = id;
        cin >> tasks[id].size_ >> tasks[id].output_data_size >> k;
        for (int j = 0; j < k; ++j) {
        	int x;
        	cin >> x;
            tasks[i].affinity_machines.insert(x);
        }
    }
    
    // 读取机器信息
    cin >> n;
    vector<Machine> machines(n + 1);
    
    for (int i = 1; i <= n; ++i) {
    	cin >> id;
    	machines[id].id = id;
        cin >> machines[id].power;
    }
    
    // 读取磁盘信息
    cin >> m;
    vector<Disk> disks(m + 1);
    
    for (int i = 1; i <= m; ++i) {
    	cin >> id;
    	disks[id].id = id;
        cin >> disks[i].rate >> disks[i].quota;
    }
    
    // 读取数据依赖信息
    cin >> N;
    vector<pair<int, int>> data_dependencies(N + 1);
    
    for (int i = 1; i <= N; ++i) {
        cin >> data_dependencies[i].first >> data_dependencies[i].second;
    }
    
    // 读取环境依赖信息
    cin >> M;
    vector<pair<int, int>> environment_dependencies(M + 1);
    
    for (int i = 1; i <= M; ++i) {
        cin >> environment_dependencies[i].first >> environment_dependencies[i].second;
    }

    // 计算任务的结束时间
//    vector<tuple<int, int, int, int, int>> results = 
	work(tasks, machines, disks, data_dependencies, environment_dependencies);

    // 输出任务的调度结果
//    for (const auto& result : results) {
//        int task_id, start_time, end_time, machine_id, disk_id;
//        tie(task_id, start_time, end_time, machine_id, disk_id) = result;
//        cout << task_id << " " << start_time << " " << machine_id << " " << disk_id << "\n";
//    }

    return 0;
}

```



### 解法三 2024/6/17

> 通过全部样例
>
> 得分 77w +
>
> 待优化点: 1. 环境依赖的依赖也把他当作数据依赖来处理，导致Machine的利用率不高
>
> 				 2. 并没有把依赖子节点比较多的Task放入读写能力比较强的Disk
>
>    				 3. Machine的出队顺序并不合理，因为Machine开始处理的时间还受到Task能够开始执行时间的影响



```c++
#include <bits/stdc++.h>

using namespace std;

int l, n, m, N, M;
// 定义任务结构体
struct Task {
    int id;
    int size_;
    int output_data_size;
    int free_cnt = 0;
    set<int> affinity_machines;
};

//优先选择的任务首先释放的子任务要多，其次是亲和机器要多 
struct CompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
        if (p1.free_cnt == p2.free_cnt){
        	return p1.affinity_machines.size() < p2.affinity_machines.size();
		}
		return p1.free_cnt < p2.free_cnt;
    }
};

// 定义机器结构体
struct Machine {
    int id;
    int power;
    int available_time = 0; // 机器的可用时间初始化为0
};
//优先最早结束
struct CompareMachine {
    bool operator()(const Machine& p1, const Machine& p2) { 
        if (p1.available_time == p2.available_time){
            return p1.power < p2.power;
        }
        return p1.available_time > p2.available_time;
        
    }
};

// 定义磁盘结构体
struct Disk {
    int id;
    int rate;
    int quota;
    int used_quota = 0; // 磁盘的已用配额初始化为0
    int available_time = 0; // 磁盘的可用时间初始化为0
};

// 优先最早结束
struct CompareDisk {
    bool operator()(const Disk& p1, const Disk& p2) { 
        if (p1.available_time == p2.available_time){
            if (p1.rate == p2.rate) {
            	return p1.quota < p2.quota;
    		}
    		return p1.rate < p2.rate;
        }
        return p1.available_time > p2.available_time;
    }
};


// 定义依赖关系结构体
struct Dependency {
    int task_id;
    int dependency_type; // 0表示数据依赖，1表示环境依赖
};

// b / a 上取整
int up(int a, int b) {
	return (a + b - 1 ) / a;
}

void debug(vector<int> &pre_cost, vector<int> &earliest_start_time) {
    for (int i = 1; i <= l; i ++){
        cout << i << "' cost:" << pre_cost[i] << "\n"; 
    }
    for (int i = 1; i <= l; i ++){
        cout << i << "' e_s_t:" << earliest_start_time[i] << "\n"; 
    }
}
// 计算任务的开始时间
void work(vector<Task>& tasks, vector<Machine>& machines, vector<Disk>& disks, vector<pair<int, int>>& data_dependencies, vector<pair<int, int>>& environment_dependencies) {
    //tuple<int, int, int, int> result;
    vector<vector<Dependency>> ps(l + 1, vector<Dependency>(0)); // 记录每个任务的被依赖父节点 
    vector<vector<Dependency>> sons(l + 1, vector<Dependency>(0)); // 记录每个任务的依赖子节点
    priority_queue<Task, vector<Task>, CompareTask> ready_tasks_pq; // 当前至少有一个Machine可以处理的就绪任务队列
	priority_queue<Machine, vector<Machine>, CompareMachine> machines_pq; //Machine优先队列
	priority_queue<Disk, vector<Disk>, CompareDisk> disks_pq;	//Machine优先队列
	vector<int> dus(l + 1, 0); //记录每个节点的读书来判断是否可以入队
	vector<int> pre_cost(l + 1, 0); // 记录每个任务需要预处理的时间 
	vector<int> earliest_start_time(l + 1, 0); // 记录每个任务至少在哪个时间点开始
	for (auto& item:data_dependencies){
    	ps[item.second].push_back({item.first, 0}); 
    	sons[item.first].push_back({item.second, 0});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	for (auto& item:environment_dependencies){
    	ps[item.second].push_back({item.first, 1});
    	sons[item.first].push_back({item.second, 1});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	//初始化就绪任务 
	for (int i = 1; i <= l; i ++){
		if (dus[i] == 0) {
			dus[i] = -1;
			ready_tasks_pq.push(tasks[i]);
		}
	}
	//初始化机器优先队列 
	for (int i = 1;i <= n; i ++){
		machines_pq.push(machines[i]);
	}
	//初始化硬盘优先队列 
	for (int i = 1;i <= m; i ++){
		disks_pq.push(disks[i]);
	}
		
	while (!ready_tasks_pq.empty()){
        //debug(pre_cost, earliest_start_time);
		auto deal_task = ready_tasks_pq.top();
		ready_tasks_pq.pop();
		int id = deal_task.id; 
		vector<Machine> machines_tmp;
		vector<Disk> disks_tmp;
        
		while (! machines_pq.empty()){
			auto deal_machine = machines_pq.top();
			machines_pq.pop();
			machines_tmp.push_back(deal_machine);
			// 亲和度满足
			if (deal_task.affinity_machines.count(deal_machine.id)) {
				break;
			}
		}
		while (! disks_pq.empty()){
			auto deal_disk = disks_pq.top();
			disks_pq.pop();
			disks_tmp.push_back(deal_disk);
			//剩余额度满足
			if  (deal_disk.quota - deal_disk.used_quota >= deal_task.output_data_size) {
				break;
			}
			
		}
        // 记录执行开始后需要花费的时间(从读取依赖开始)
		int cost_time = 0;
		int machines_idx = machines_tmp.size() - 1;
		int disks_idx = disks_tmp.size() - 1;
		auto &deal_machine = machines_tmp[machines_idx];
		auto &deal_disk = disks_tmp[disks_idx];		
		int arrival_time = max({deal_machine.available_time, deal_disk.available_time, earliest_start_time[id]});
		deal_machine.available_time = arrival_time;
		deal_disk.available_time = arrival_time;
		cout << id << " " << arrival_time << " " << deal_machine.id << " " <<  deal_disk.id << "\n";
		cost_time += pre_cost[id];
        cost_time += up(deal_machine.power, deal_task.size_);
		cost_time += up(deal_disk.rate, deal_task.output_data_size);

		//使用的mahcine和disk更新参数
		deal_machine.available_time += cost_time;
		deal_disk.available_time += cost_time;
		deal_disk.used_quota += deal_task.output_data_size;
		
		//出队的machine和disk重新入队
		for (auto m:machines_tmp){
			machines_pq.push(m);
		} 

		for (auto d:disks_tmp){
			disks_pq.push(d);
		} 		
		
		//释放依赖并为其依赖加上读取时间(若必要的话) 
		for (auto &son:sons[id]){
			dus[son.task_id] -= 1;
			//由于它有可能有很多依赖，所以需要更新为最迟结束的那个依赖 
			earliest_start_time[son.task_id] = max(earliest_start_time[son.task_id], arrival_time + cost_time);
			if (son.dependency_type == 0) {
				pre_cost[son.task_id] += up(deal_disk.rate, deal_task.output_data_size);
			}
			if (dus[son.task_id] == 0) {
				ready_tasks_pq.push(tasks[son.task_id]);
			}
		}
		
		
	}
	
}

int main() {
	
    
    cin >> l;
    vector<Task> tasks(l + 1);
    int id;
    // 读取任务信息
    for (int i = 1; i <= l; ++i) {
        int k;
        cin >> id;
        tasks[id].id = id;
        cin >> tasks[id].size_ >> tasks[id].output_data_size >> k;
        for (int j = 0; j < k; ++j) {
        	int x;
        	cin >> x;
            tasks[i].affinity_machines.insert(x);
        }
    }
    
    // 读取机器信息
    cin >> n;
    vector<Machine> machines(n + 1);
    
    for (int i = 1; i <= n; ++i) {
    	cin >> id;
    	machines[id].id = id;
        cin >> machines[id].power;
    }
    
    // 读取磁盘信息
    cin >> m;
    vector<Disk> disks(m + 1);
    
    for (int i = 1; i <= m; ++i) {
    	cin >> id;
    	disks[id].id = id;
        cin >> disks[i].rate >> disks[i].quota;
    }
    
    // 读取数据依赖信息
    cin >> N;
    vector<pair<int, int>> data_dependencies(N + 1);
    
    for (int i = 1; i <= N; ++i) {
        cin >> data_dependencies[i].first >> data_dependencies[i].second;
    }
    
    // 读取环境依赖信息
    cin >> M;
    vector<pair<int, int>> environment_dependencies(M + 1);
    
    for (int i = 1; i <= M; ++i) {
        cin >> environment_dependencies[i].first >> environment_dependencies[i].second;
    }

	work(tasks, machines, disks, data_dependencies, environment_dependencies);


    return 0;
}

```



### 解法四 2024/6/18

> 针对解法三优化:
>
> 1. 每个Task加上earliest_start_time 字段，这样优先结束的Machine就可以处理优先开始的Task
>
>  	2. Task，Disk，Machine的队列优先级优化
>
> 分数 132w+

```c++
#include <bits/stdc++.h>

using namespace std;

int l, n, m, N, M;
// 定义任务结构体
struct Task {
    int id;
    int size_;
    int output_data_size;
    int earliest_start_time = 0;
    int free_cnt = 0;
    set<int> affinity_machines;
};

//1. 开始时间早 2. 亲和机器多 3. 释放数量多
struct CompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
        if (p1.earliest_start_time == p2.earliest_start_time) {
            if (p1.affinity_machines.size() == p2.affinity_machines.size()){
                return p1.free_cnt < p2.free_cnt;
            }
            return p1.affinity_machines.size() < p2.affinity_machines.size();
        }
        return p1.earliest_start_time > p2.earliest_start_time;
    }
};

// 定义机器结构体
struct Machine {
    int id;
    int power;
    int available_time = 0; // 机器的可用时间初始化为0
};
struct CompareMachine {
    bool operator()(const Machine& p1, const Machine& p2) { 
//        if (p1.available_time == p2.available_time){
//            return p1.power < p2.power;
//        }
//        return p1.available_time > p2.available_time;
		
		//优先处理能力 
		if (p1.power == p2.power){
            return p1.available_time > p2.available_time;
        }
        return p1.power < p2.power;     
    }
};

// 定义磁盘结构体
struct Disk {
    int id;
    int rate;
    int quota;
    int used_quota = 0; // 磁盘的已用配额初始化为0
    int available_time = 0; // 磁盘的可用时间初始化为0
};

struct CompareDisk {
    bool operator()(const Disk& p1, const Disk& p2) { 
        if (p1.available_time == p2.available_time){
            if (p1.rate == p2.rate) {
            	return p1.quota - p1.used_quota < p2.quota - p2.used_quota;
    		}
    		return p1.rate < p2.rate;
        }
        return p1.available_time > p2.available_time;
		//优先速度快 
//		if (p1.rate == p2.rate){
//            if (p1.available_time == p2.available_time) {
//            	return p1.quota - p1.used_quota < p2.quota - p2.used_quota;
//    		}
//    		return p1.available_time > p2.available_time;
//        }
//        return p1.rate == p2.rate; 
    }
};


// 定义依赖关系结构体
struct Dependency {
    int task_id;
    int dependency_type; // 0表示数据依赖，1表示环境依赖
};

// b / a 上取整
int up(int a, int b) {
	return (a + b - 1 ) / a;
}

void debug(vector<int> &pre_cost, vector<int> &earliest_start_time) {
    for (int i = 1; i <= l; i ++){
        cout << i << "' cost:" << pre_cost[i] << "\n"; 
    }
    for (int i = 1; i <= l; i ++){
        cout << i << "' e_s_t:" << earliest_start_time[i] << "\n"; 
    }
}
// 计算任务的开始时间
void work(vector<Task>& tasks, vector<Machine>& machines, vector<Disk>& disks, vector<pair<int, int>>& data_dependencies, vector<pair<int, int>>& environment_dependencies) {
    //tuple<int, int, int, int> result;
    vector<vector<Dependency>> ps(l + 1, vector<Dependency>(0)); // 记录每个任务的被依赖父节点 
    vector<vector<Dependency>> sons(l + 1, vector<Dependency>(0)); // 记录每个任务的依赖子节点
    priority_queue<Task, vector<Task>, CompareTask> ready_tasks_pq; // 当前至少有一个Machine可以处理的就绪任务队列
	priority_queue<Machine, vector<Machine>, CompareMachine> machines_pq; //Machine优先队列
	priority_queue<Disk, vector<Disk>, CompareDisk> disks_pq;	//Machine优先队列
	vector<int> dus(l + 1, 0); //记录每个节点的读书来判断是否可以入队
	vector<int> pre_cost(l + 1, 0); // 记录每个任务需要预处理的时间 
	vector<int> earliest_start_time(l + 1, 0); // 记录每个任务至少在哪个时间点开始
	for (auto& item:data_dependencies){
    	ps[item.second].push_back({item.first, 0}); 
    	sons[item.first].push_back({item.second, 0});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	for (auto& item:environment_dependencies){
    	ps[item.second].push_back({item.first, 1});
    	sons[item.first].push_back({item.second, 1});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	//初始化就绪任务 
	for (int i = 1; i <= l; i ++){
		if (dus[i] == 0) {
			dus[i] = -1;
			ready_tasks_pq.push(tasks[i]);
		}
	}
	//初始化机器优先队列 
	for (int i = 1;i <= n; i ++){
		machines_pq.push(machines[i]);
	}
	//初始化硬盘优先队列 
	for (int i = 1;i <= m; i ++){
		disks_pq.push(disks[i]);
	}
		
	while (!ready_tasks_pq.empty()){
        //debug(pre_cost, earliest_start_time);
		auto deal_task = ready_tasks_pq.top();
		ready_tasks_pq.pop();
		int id = deal_task.id; 
		vector<Machine> machines_tmp;
		vector<Disk> disks_tmp;
        // 选择Machine和Disk也是可以优化的，因为时间差距有可能比较大
		while (! machines_pq.empty()){
			auto deal_machine = machines_pq.top();
			machines_pq.pop();
			machines_tmp.push_back(deal_machine);
			// 亲和度满足
			if (deal_task.affinity_machines.count(deal_machine.id)) {
				break;
			}
		}
		while (! disks_pq.empty()){
			auto deal_disk = disks_pq.top();
			disks_pq.pop();
			disks_tmp.push_back(deal_disk);
			//剩余额度满足
			if  (deal_disk.quota - deal_disk.used_quota >= deal_task.output_data_size) {
				break;
			}
			
		}
        // 记录执行开始后需要花费的时间(从读取依赖开始)
		int cost_time = 0;
		int machines_idx = machines_tmp.size() - 1;
		int disks_idx = disks_tmp.size() - 1;
		auto &deal_machine = machines_tmp[machines_idx];
		auto &deal_disk = disks_tmp[disks_idx];		
		int arrival_time = max({deal_machine.available_time, deal_disk.available_time, earliest_start_time[id]});
		deal_machine.available_time = arrival_time;
		deal_disk.available_time = arrival_time;
		cout << id << " " << arrival_time << " " << deal_machine.id << " " <<  deal_disk.id << "\n";
		cost_time += pre_cost[id];
        cost_time += up(deal_machine.power, deal_task.size_);
		cost_time += up(deal_disk.rate, deal_task.output_data_size);

		//使用的mahcine和disk更新参数
		deal_machine.available_time += cost_time;
		deal_disk.available_time += cost_time;
		deal_disk.used_quota += deal_task.output_data_size;
		
		//出队的machine和disk重新入队
		for (auto m:machines_tmp){
			machines_pq.push(m);
		} 

		for (auto d:disks_tmp){
			disks_pq.push(d);
		} 		
		
		//释放依赖并为其依赖加上读取时间(若必要的话) 
		for (auto &son:sons[id]){
			dus[son.task_id] -= 1;
			//由于它有可能有很多依赖，所以需要更新为最迟结束的那个依赖 
			earliest_start_time[son.task_id] = max(earliest_start_time[son.task_id], arrival_time + cost_time);
			if (son.dependency_type == 0) {
				pre_cost[son.task_id] += up(deal_disk.rate, deal_task.output_data_size);
			}
			if (dus[son.task_id] == 0) {
                tasks[son.task_id].earliest_start_time = earliest_start_time[son.task_id];
				ready_tasks_pq.push(tasks[son.task_id]);
			}
		}
		
		
	}
	
}

int main() {
	
    
    cin >> l;
    vector<Task> tasks(l + 1);
    int id;
    // 读取任务信息
    for (int i = 1; i <= l; ++i) {
        int k;
        cin >> id;
        tasks[id].id = id;
        cin >> tasks[id].size_ >> tasks[id].output_data_size >> k;
        for (int j = 0; j < k; ++j) {
        	int x;
        	cin >> x;
            tasks[i].affinity_machines.insert(x);
        }
    }
    
    // 读取机器信息
    cin >> n;
    vector<Machine> machines(n + 1);
    
    for (int i = 1; i <= n; ++i) {
    	cin >> id;
    	machines[id].id = id;
        cin >> machines[id].power;
    }
    
    // 读取磁盘信息
    cin >> m;
    vector<Disk> disks(m + 1);
    
    for (int i = 1; i <= m; ++i) {
    	cin >> id;
    	disks[id].id = id;
        cin >> disks[i].rate >> disks[i].quota;
    }
    
    // 读取数据依赖信息
    cin >> N;
    vector<pair<int, int>> data_dependencies(N + 1);
    
    for (int i = 1; i <= N; ++i) {
        cin >> data_dependencies[i].first >> data_dependencies[i].second;
    }
    
    // 读取环境依赖信息
    cin >> M;
    vector<pair<int, int>> environment_dependencies(M + 1);
    
    for (int i = 1; i <= M; ++i) {
        cin >> environment_dependencies[i].first >> environment_dependencies[i].second;
    }

	work(tasks, machines, disks, data_dependencies, environment_dependencies);

    return 0;
}

```

### 解法五 2024/6/18

> 优化点: 
>
> 1.  优化每个任务的输出磁盘, 固定部分依赖子集个数*输出大小比较大的Task到rate强的磁盘上 
>
> 缺点:在大多数样例上都会造成磁盘饥饿
>
> 分数: 132w+
>
> 

```c++
#include <bits/stdc++.h>

using namespace std;

int l, n, m, N, M, total_pre_data = 0;
// 定义任务结构体
struct Task {
    int id;
    int size_;
    int output_data_size;
    int earliest_start_time = 0;
    int free_cnt = 0;
    set<int> affinity_machines;
};

//1. 开始时间早 2. 亲和机器多 3. 释放数量多
struct CompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
        if (p1.earliest_start_time == p2.earliest_start_time) {
            if (p1.affinity_machines.size() == p2.affinity_machines.size()){
                return p1.free_cnt < p2.free_cnt;
            }
            return p1.affinity_machines.size() < p2.affinity_machines.size();
        }
        return p1.earliest_start_time > p2.earliest_start_time;
    }
};

// 定义机器结构体
struct Machine {
    int id;
    int power;
    int available_time = 0; // 机器的可用时间初始化为0
};
struct CompareMachine {
    bool operator()(const Machine& p1, const Machine& p2) { 
//        if (p1.available_time == p2.available_time){
//            return p1.power < p2.power;
//        }
//        return p1.available_time > p2.available_time;
		
		//优先处理能力 
		if (p1.power == p2.power){
            return p1.available_time > p2.available_time;
        }
        return p1.power < p2.power;     
    }
};

// 定义磁盘结构体
struct Disk {
    int id;
    int rate;
    int quota;
    int used_quota = 0; // 磁盘的已用配额初始化为0
    int available_time = 0; // 磁盘的可用时间初始化为0
};

struct CompareDisk {
    bool operator()(const Disk& p1, const Disk& p2) { 
        if (p1.available_time == p2.available_time){
            if (p1.rate == p2.rate) {
            	return p1.quota - p1.used_quota < p2.quota - p2.used_quota;
    		}
    		return p1.rate < p2.rate;
        }
        return p1.available_time > p2.available_time;
		
    }
};
struct CompareDiskFixed {
    bool operator()(const Disk& p1, const Disk& p2) { 
		//优先速度快 
		if (p1.rate == p2.rate){
            return p1.quota - p1.used_quota < p2.quota - p2.used_quota;	
        }
        return p1.rate < p2.rate; 
    }
};


// 定义依赖关系结构体
struct Dependency {
    int task_id;
    int dependency_type; // 0表示数据依赖，1表示环境依赖
};

// b / a 上取整
int up(int a, int b) {
	return (a + b - 1 ) / a;
}

void debug(vector<int> &pre_cost, vector<int> &earliest_start_time) {
    for (int i = 1; i <= l; i ++){
        cout << i << "' cost:" << pre_cost[i] << "\n"; 
    }
    for (int i = 1; i <= l; i ++){
        cout << i << "' e_s_t:" << earliest_start_time[i] << "\n"; 
    }
}
// 计算任务的开始时间
void work(vector<Task>& tasks, vector<Machine>& machines, vector<Disk>& disks, vector<pair<int, int>>& data_dependencies, vector<pair<int, int>>& environment_dependencies) {
    //tuple<int, int, int, int> result;
    vector<vector<Dependency>> ps(l + 1, vector<Dependency>(0)); // 记录每个任务的被依赖父节点 
    vector<vector<Dependency>> sons(l + 1, vector<Dependency>(0)); // 记录每个任务的依赖子节点
    priority_queue<Task, vector<Task>, CompareTask> ready_tasks_pq; // 当前至少有一个Machine可以处理的就绪任务队列
	priority_queue<Machine, vector<Machine>, CompareMachine> machines_pq; //Machine优先队列
	priority_queue<Disk, vector<Disk>, CompareDisk> disks_pq;	//Disk优先队列
    priority_queue<Disk, vector<Disk>, CompareDiskFixed> disks_pq_fixed;	//Disk优先队列
    unordered_map<int, int> tasks_disk;// 重要Task的固定Disk 每个测试样例动态分配
	vector<int> dus(l + 1, 0); //记录每个节点的读书来判断是否可以入队
	vector<int> pre_cost(l + 1, 0); // 记录每个任务需要预处理的时间 
    vector<int> pre_data(l + 1, 0); // 记录每个任务被依赖子节点读取的数据量大小 
    
	vector<int> earliest_start_time(l + 1, 0); // 记录每个任务至少在哪个时间点开始
	for (auto& item:data_dependencies){
    	ps[item.second].push_back({item.first, 0}); 
    	sons[item.first].push_back({item.second, 0});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
        total_pre_data += tasks[item.first].output_data_size;
        pre_data[item.first] += tasks[item.first].output_data_size;
	}
	
	for (auto& item:environment_dependencies){
    	ps[item.second].push_back({item.first, 1});
    	sons[item.first].push_back({item.second, 1});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	//初始化就绪任务 
	for (int i = 1; i <= l; i ++){
		if (dus[i] == 0) {
			dus[i] = -1;
			ready_tasks_pq.push(tasks[i]);
		}
	}
	//初始化机器优先队列 
	for (int i = 1;i <= n; i ++){
		machines_pq.push(machines[i]);
	}
	
    
    //初始化硬盘固定优先队列 
	for (int i = 1;i <= m; i ++){
		disks_pq_fixed.push(disks[i]);
	}
    
    //动态分配某些Task为固定的Disk
    int avg_pre_data = total_pre_data / N; 
    for (int i = 1; i <= l; i ++) {
        int t = pre_data[i];
        int data = tasks[i].output_data_size;
        if (t >= 3 * avg_pre_data) {
            vector<Disk> disks_tmp;
            while (! disks_pq_fixed.empty()){
                auto deal_disk = disks_pq_fixed.top();
                disks_pq_fixed.pop();
                //剩余额度满足
                if  (deal_disk.quota - deal_disk.used_quota >= data) {
                    deal_disk.used_quota += data;
                    disks[deal_disk.id].used_quota += data;
                    disks_pq_fixed.push(deal_disk);
                    tasks_disk[i] = deal_disk.id;
                    //cout << i << ":" << tasks_disk[i] << "\n";
                    break;
                }
                disks_tmp.push_back(deal_disk);
			}
            for (auto tt: disks_tmp) {
                disks_pq_fixed.push(tt);
            }
        }
        
    }
    
    //由于Disk的容量可能会变化，所以后初始化硬盘优先队列 
	for (int i = 1;i <= m; i ++){
		disks_pq.push(disks[i]);
		//cout << disks[i].rate << ":" << disks[i].quota << "\n";
	}
		
	while (!ready_tasks_pq.empty()){
//        debug(pre_cost, earliest_start_time);
		auto deal_task = ready_tasks_pq.top();
		ready_tasks_pq.pop();
		int id = deal_task.id; 
		vector<Machine> machines_tmp;
		vector<Disk> disks_tmp;
        // 选择Machine和Disk也是可以优化的，因为时间差距有可能比较大
		while (! machines_pq.empty()){
			auto deal_machine = machines_pq.top();
			machines_pq.pop();
			machines_tmp.push_back(deal_machine);
			// 亲和度满足
			if (deal_task.affinity_machines.count(deal_machine.id)) {
				break;
			}
		}
        if (tasks_disk[id] == 0){
            while (! disks_pq.empty()){
                auto deal_disk = disks_pq.top();
                disks_pq.pop();
                disks_tmp.push_back(deal_disk);
                //剩余额度满足
                if  (deal_disk.quota - deal_disk.used_quota >= deal_task.output_data_size) {
                    break;
                }
            }
        }
		else{
			while (! disks_pq.empty()){ 
                auto deal_disk = disks_pq.top();
                disks_pq.pop();
                disks_tmp.push_back(deal_disk);
                //到固定的Disk了 
                if  (deal_disk.id == tasks_disk[id]) {
                    break;
                }
            }
		} 
        // 记录执行开始后需要花费的时间(从读取依赖开始)
		int cost_time = 0;
		int machines_idx = machines_tmp.size() - 1;
		int disks_idx = disks_tmp.size() - 1;
		auto &deal_machine = machines_tmp[machines_idx];
		auto &deal_disk = disks_tmp[disks_idx];		
		int arrival_time = max({deal_machine.available_time, deal_disk.available_time, earliest_start_time[id]});
		deal_machine.available_time = arrival_time;
		deal_disk.available_time = arrival_time;
		cout << id << " " << arrival_time << " " << deal_machine.id << " " <<  deal_disk.id << "\n";
		cost_time += pre_cost[id];
        cost_time += up(deal_machine.power, deal_task.size_);
		cost_time += up(deal_disk.rate, deal_task.output_data_size);

		//使用的mahcine和disk更新参数
		deal_machine.available_time += cost_time;
		deal_disk.available_time += cost_time;
		if (tasks_disk[id] == 0) {
			deal_disk.used_quota += deal_task.output_data_size;
		}
		
		//出队的machine和disk重新入队
		for (auto m:machines_tmp){
			machines_pq.push(m);
		} 

		for (auto d:disks_tmp){
			disks_pq.push(d);
		} 		
		
		//释放依赖并为其依赖加上读取时间(若必要的话) 
		for (auto &son:sons[id]){
			dus[son.task_id] -= 1;
			//由于它有可能有很多依赖，所以需要更新为最迟结束的那个依赖 
			earliest_start_time[son.task_id] = max(earliest_start_time[son.task_id], arrival_time + cost_time);
			if (son.dependency_type == 0) {
				pre_cost[son.task_id] += up(deal_disk.rate, deal_task.output_data_size);
			}
			if (dus[son.task_id] == 0) {
                tasks[son.task_id].earliest_start_time = earliest_start_time[son.task_id];
				ready_tasks_pq.push(tasks[son.task_id]);
			}
		}
		
		
	}
	
}

int main() {
	
    
    cin >> l;
    vector<Task> tasks(l + 1);
    int id;
    // 读取任务信息
    for (int i = 1; i <= l; ++i) {
        int k;
        cin >> id;
        tasks[id].id = id;
        cin >> tasks[id].size_ >> tasks[id].output_data_size >> k;
        for (int j = 0; j < k; ++j) {
        	int x;
        	cin >> x;
            tasks[i].affinity_machines.insert(x);
        }
    }
    
    // 读取机器信息
    cin >> n;
    vector<Machine> machines(n + 1);
    
    for (int i = 1; i <= n; ++i) {
    	cin >> id;
    	machines[id].id = id;
        cin >> machines[id].power;
    }
    
    // 读取磁盘信息
    cin >> m;
    vector<Disk> disks(m + 1);
    
    for (int i = 1; i <= m; ++i) {
    	cin >> id;
    	disks[id].id = id;
        cin >> disks[i].rate >> disks[i].quota;
    }
    
    // 读取数据依赖信息
    cin >> N;
    vector<pair<int, int>> data_dependencies(N + 1);
    
    for (int i = 1; i <= N; ++i) {
        cin >> data_dependencies[i].first >> data_dependencies[i].second;
    }
    
    // 读取环境依赖信息
    cin >> M;
    vector<pair<int, int>> environment_dependencies(M + 1);
    
    for (int i = 1; i <= M; ++i) {
        cin >> environment_dependencies[i].first >> environment_dependencies[i].second;
    }

	work(tasks, machines, disks, data_dependencies, environment_dependencies);

    return 0;
}

```



### 解法六 2024/6/19

> 基于解法四
>
> 不需要考虑Disk的可用时间
>
> 得分：188w+



```c++
#include <bits/stdc++.h>

using namespace std;

int l, n, m, N, M;
// 定义任务结构体
struct Task {
    int id;
    int size_;
    int output_data_size;
    int earliest_start_time = 0;
    int free_cnt = 0;
    set<int> affinity_machines;
};

//1. 开始时间早 2. 亲和机器多 3. 释放数量多
struct CompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
        if (p1.earliest_start_time == p2.earliest_start_time) {
            if (p1.affinity_machines.size() == p2.affinity_machines.size()){
                return p1.free_cnt < p2.free_cnt;
            }
            return p1.affinity_machines.size() < p2.affinity_machines.size();
        }
        return p1.earliest_start_time > p2.earliest_start_time;
    }
};

// 定义机器结构体
struct Machine {
    int id;
    int power;
    int available_time = 0; // 机器的可用时间初始化为0
    queue<Task> q; //处理过的任务
};
struct CompareMachine {
    bool operator()(const Machine& p1, const Machine& p2) { 
//        if (p1.available_time == p2.available_time){
//            return p1.power < p2.power;
//        }
//        return p1.available_time > p2.available_time;
		
		//优先处理能力 
		if (p1.power == p2.power){
            return p1.available_time > p2.available_time;
        }
        return p1.power < p2.power;     
    }
};

// 定义磁盘结构体
struct Disk {
    int id;
    int rate;
    int quota;
    int used_quota = 0; // 磁盘的已用配额初始化为0
    int available_time = 0; // 磁盘的可用时间初始化为0
    queue<Task> q; //存储过的任务
};

struct CompareDisk {
    bool operator()(const Disk& p1, const Disk& p2) { 
        if (p1.available_time == p2.available_time){
            if (p1.rate == p2.rate) {
            	return p1.quota - p1.used_quota < p2.quota - p2.used_quota;
    		}
    		return p1.rate < p2.rate;
        }
        return p1.available_time > p2.available_time;
		//优先速度快 
//		if (p1.rate == p2.rate){
//            if (p1.available_time == p2.available_time) {
//            	return p1.quota - p1.used_quota < p2.quota - p2.used_quota;
//    		}
//    		return p1.available_time > p2.available_time;
//        }
//        return p1.rate == p2.rate; 
    }
};


// 定义依赖关系结构体
struct Dependency {
    int task_id;
    int dependency_type; // 0表示数据依赖，1表示环境依赖
};

// b / a 上取整
int up(int a, int b) {
	return (a + b - 1 ) / a;
}

void debug(vector<int> &pre_cost, vector<int> &earliest_start_time) {
    for (int i = 1; i <= l; i ++){
        cout << i << "' cost:" << pre_cost[i] << "\n"; 
    }
    for (int i = 1; i <= l; i ++){
        cout << i << "' e_s_t:" << earliest_start_time[i] << "\n"; 
    }
}
// 计算任务的开始时间
void work(vector<Task>& tasks, vector<Machine>& machines, vector<Disk>& disks, vector<pair<int, int>>& data_dependencies, vector<pair<int, int>>& environment_dependencies) {
    //tuple<int, int, int, int> result;
    vector<vector<Dependency>> ps(l + 1, vector<Dependency>(0)); // 记录每个任务的被依赖父节点 
    vector<vector<Dependency>> sons(l + 1, vector<Dependency>(0)); // 记录每个任务的依赖子节点
    priority_queue<Task, vector<Task>, CompareTask> ready_tasks_pq; // 当前至少有一个Machine可以处理的就绪任务队列
	priority_queue<Machine, vector<Machine>, CompareMachine> machines_pq; //Machine优先队列
	priority_queue<Disk, vector<Disk>, CompareDisk> disks_pq;	//Disk优先队列
	vector<int> dus(l + 1, 0); //记录每个节点的读书来判断是否可以入队
	vector<int> pre_cost(l + 1, 0); // 记录每个任务需要预处理的时间 
	vector<int> earliest_start_time(l + 1, 0); // 记录每个任务至少在哪个时间点开始
	for (auto& item:data_dependencies){
    	ps[item.second].push_back({item.first, 0}); 
    	sons[item.first].push_back({item.second, 0});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	for (auto& item:environment_dependencies){
    	ps[item.second].push_back({item.first, 1});
    	sons[item.first].push_back({item.second, 1});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	//初始化就绪任务 
	for (int i = 1; i <= l; i ++){
		if (dus[i] == 0) {
			dus[i] = -1;
			ready_tasks_pq.push(tasks[i]);
		}
	}
	//初始化机器优先队列 
	for (int i = 1;i <= n; i ++){
		machines_pq.push(machines[i]);
	}
	//初始化硬盘优先队列 
	for (int i = 1;i <= m; i ++){
		disks_pq.push(disks[i]);
	}
		
	while (!ready_tasks_pq.empty()){
        //debug(pre_cost, earliest_start_time);
		auto deal_task = ready_tasks_pq.top();
		ready_tasks_pq.pop();
		int id = deal_task.id; 
		vector<Machine> machines_tmp;
		vector<Disk> disks_tmp;
        // 选择Machine和Disk也是可以优化的，因为时间差距有可能比较大
		while (! machines_pq.empty()){
			auto deal_machine = machines_pq.top();
			machines_pq.pop();
			machines_tmp.push_back(deal_machine);
			// 亲和度满足
			if (deal_task.affinity_machines.count(deal_machine.id)) {
				break;
			}
		}
		while (! disks_pq.empty()){
			auto deal_disk = disks_pq.top();
			disks_pq.pop();
			disks_tmp.push_back(deal_disk);
			//剩余额度满足
			if  (deal_disk.quota - deal_disk.used_quota >= deal_task.output_data_size) {
				break;
			}
			
		}
        // 记录执行开始后需要花费的时间(从读取依赖开始)
		int cost_time = 0;
		int machines_idx = machines_tmp.size() - 1;
		int disks_idx = disks_tmp.size() - 1;
		auto &deal_machine = machines_tmp[machines_idx];
		auto &deal_disk = disks_tmp[disks_idx];		
		int arrival_time = max({deal_machine.available_time, earliest_start_time[id]});
		deal_machine.available_time = arrival_time;
		deal_disk.available_time = arrival_time;
		cout << id << " " << arrival_time << " " << deal_machine.id << " " <<  deal_disk.id << "\n";
		cost_time += pre_cost[id];
        cost_time += up(deal_machine.power, deal_task.size_);
		cost_time += up(deal_disk.rate, deal_task.output_data_size);

		//使用的mahcine和disk更新参数 (这里要根据数据依赖或是环境依赖来更新) 
		deal_machine.available_time += cost_time;
		deal_disk.used_quota += deal_task.output_data_size;
		
		//出队的machine和disk重新入队
		for (auto m:machines_tmp){
			machines_pq.push(m);
		} 

		for (auto d:disks_tmp){
			disks_pq.push(d);
		} 		
		
		//释放依赖并为其依赖加上读取时间(若必要的话) 
		for (auto &son:sons[id]){
			dus[son.task_id] -= 1;
			//由于它有可能有很多依赖，所以需要更新为最迟结束的那个依赖 
			earliest_start_time[son.task_id] = max(earliest_start_time[son.task_id], arrival_time + cost_time);
			if (son.dependency_type == 0) {
				pre_cost[son.task_id] += up(deal_disk.rate, deal_task.output_data_size);
			}
			if (dus[son.task_id] == 0) {
                tasks[son.task_id].earliest_start_time = earliest_start_time[son.task_id];
				ready_tasks_pq.push(tasks[son.task_id]);
			}
		}
		
		
	}
	
}

int main() {
	
    
    cin >> l;
    vector<Task> tasks(l + 1);
    int id;
    // 读取任务信息
    for (int i = 1; i <= l; ++i) {
        int k;
        cin >> id;
        tasks[id].id = id;
        cin >> tasks[id].size_ >> tasks[id].output_data_size >> k;
        for (int j = 0; j < k; ++j) {
        	int x;
        	cin >> x;
            tasks[i].affinity_machines.insert(x);
        }
    }
    
    // 读取机器信息
    cin >> n;
    vector<Machine> machines(n + 1);
    
    for (int i = 1; i <= n; ++i) {
    	cin >> id;
    	machines[id].id = id;
        cin >> machines[id].power;
    }
    
    // 读取磁盘信息
    cin >> m;
    vector<Disk> disks(m + 1);
    
    for (int i = 1; i <= m; ++i) {
    	cin >> id;
    	disks[id].id = id;
        cin >> disks[i].rate >> disks[i].quota;
    }
    
    // 读取数据依赖信息
    cin >> N;
    vector<pair<int, int>> data_dependencies(N + 1);
    
    for (int i = 1; i <= N; ++i) {
        cin >> data_dependencies[i].first >> data_dependencies[i].second;
    }
    
    // 读取环境依赖信息
    cin >> M;
    vector<pair<int, int>> environment_dependencies(M + 1);
    
    for (int i = 1; i <= M; ++i) {
        cin >> environment_dependencies[i].first >> environment_dependencies[i].second;
    }

	work(tasks, machines, disks, data_dependencies, environment_dependencies);

    return 0;
}

```

### 解法七 2024/6/19

> 基于解法五
>
> 不需要考虑Disk的可用时间 + Task根据被依赖数据量贪心选择速度快的磁盘
>
> 分数:193w+

```c++
#include <bits/stdc++.h>

using namespace std;

int l, n, m, N, M;
// 定义任务结构体
struct Task {
    int id;
    int size_;
    int output_data_size;
    int earliest_start_time = 0;
    int free_cnt = 0;
    int total_pre_data = 0;
    set<int> affinity_machines;
};

//1. 开始时间早 2. 亲和机器多 3. 释放数量多
struct CompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
        if (p1.earliest_start_time == p2.earliest_start_time) {
            if (p1.affinity_machines.size() == p2.affinity_machines.size()){
                return p1.free_cnt < p2.free_cnt;
            }
            return p1.affinity_machines.size() < p2.affinity_machines.size();
        }
        return p1.earliest_start_time > p2.earliest_start_time;
    }
};

struct PreCompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
//    	if (p1.total_pre_data == p2.total_pre_data) {
//    		return p1.output_data_size > p2.output_data_size;
//		}
        return p1.total_pre_data < p2.total_pre_data;
    }
};
// 定义机器结构体
struct Machine {
    int id;
    int power;
    int available_time = 0; // 机器的可用时间初始化为0
};
struct CompareMachine {
    bool operator()(const Machine& p1, const Machine& p2) { 
		
		//优先处理能力 
		if (p1.power == p2.power){
            return p1.available_time > p2.available_time;
        }
        return p1.power < p2.power;     
    }
};

// 定义磁盘结构体
struct Disk {
    int id;
    int rate;
    int quota;
    int used_quota = 0; // 磁盘的已用配额初始化为0
};

struct CompareDisk {
    bool operator()(const Disk& p1, const Disk& p2) { 
       
        if (p1.rate == p2.rate) {
        	return p1.quota - p1.used_quota < p2.quota - p2.used_quota;
		}
		return p1.rate < p2.rate;
        
    }
};


// 定义依赖关系结构体
struct Dependency {
    int task_id;
    int dependency_type; // 0表示数据依赖，1表示环境依赖
};

// b / a 上取整
int up(int a, int b) {
	return (a + b - 1 ) / a;
}

void debug(vector<int> &pre_cost, vector<int> &earliest_start_time) {
    for (int i = 1; i <= l; i ++){
        cout << i << "' cost:" << pre_cost[i] << "\n"; 
    }
    for (int i = 1; i <= l; i ++){
        cout << i << "' e_s_t:" << earliest_start_time[i] << "\n"; 
    }
}
// 计算任务的开始时间
void work(vector<Task>& tasks, vector<Machine>& machines, vector<Disk>& disks, vector<pair<int, int>>& data_dependencies, vector<pair<int, int>>& environment_dependencies) {
    //tuple<int, int, int, int> result;
    vector<vector<Dependency>> ps(l + 1, vector<Dependency>(0)); // 记录每个任务的被依赖父节点 
    vector<vector<Dependency>> sons(l + 1, vector<Dependency>(0)); // 记录每个任务的依赖子节点
    priority_queue<Task, vector<Task>, CompareTask> ready_tasks_pq; // 当前至少有一个Machine可以处理的就绪任务队列
	priority_queue<Task, vector<Task>, PreCompareTask> pre_tasks_pq; // 预分配每个Task对应的Disk 
	priority_queue<Machine, vector<Machine>, CompareMachine> machines_pq; //Machine优先队列
    priority_queue<Disk, vector<Disk>, CompareDisk> disks_pq_fixed;	//Disk固定优先队列
    unordered_map<int, int> tasks_disk;// 重要Task的固定Disk 每个测试样例动态分配
	vector<int> dus(l + 1, 0); //记录每个节点的读书来判断是否可以入队
	vector<int> pre_cost(l + 1, 0); // 记录每个任务需要预处理的时间 
    
	vector<int> earliest_start_time(l + 1, 0); // 记录每个任务至少在哪个时间点开始
	for (auto& item:data_dependencies){
    	ps[item.second].push_back({item.first, 0}); 
    	sons[item.first].push_back({item.second, 0});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
        tasks[item.first].total_pre_data += tasks[item.first].output_data_size;
        
	}
	
	for (auto& item:environment_dependencies){
    	ps[item.second].push_back({item.first, 1});
    	sons[item.first].push_back({item.second, 1});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	//初始化就绪任务 
	for (int i = 1; i <= l; i ++){
		if (dus[i] == 0) {
			dus[i] = -1;
			ready_tasks_pq.push(tasks[i]);
		}
		pre_tasks_pq.push(tasks[i]);
	}
	//初始化机器优先队列 
	for (int i = 1;i <= n; i ++){
		machines_pq.push(machines[i]);
	}
	
    
    //初始化硬盘固定优先队列 
	for (int i = 1;i <= m; i ++){
		disks_pq_fixed.push(disks[i]);
	}
    
    //动态分配Task为固定的Disk
    while (! pre_tasks_pq.empty()) {
    	auto deal_task = pre_tasks_pq.top();
    	pre_tasks_pq.pop();
        int id = deal_task.id;
        int data = deal_task.output_data_size;
        vector<Disk> disks_tmp;
        while (! disks_pq_fixed.empty()){
            auto deal_disk = disks_pq_fixed.top();
            disks_pq_fixed.pop();
            //剩余额度满足
            if  (deal_disk.quota - deal_disk.used_quota >= data) {
                deal_disk.used_quota += data;
                disks[deal_disk.id].used_quota += data;
                disks_pq_fixed.push(deal_disk);
                tasks_disk[id] = deal_disk.id;
                break;
            }
            disks_tmp.push_back(deal_disk);
		}
        for (auto tt: disks_tmp) {
            disks_pq_fixed.push(tt);
        }
        
    }
    
	while (!ready_tasks_pq.empty()){
//        debug(pre_cost, earliest_start_time);
		auto deal_task = ready_tasks_pq.top();
		ready_tasks_pq.pop();
		int id = deal_task.id; 
		vector<Machine> machines_tmp;
		while (! machines_pq.empty()){
			auto deal_machine = machines_pq.top();
			machines_pq.pop();
			machines_tmp.push_back(deal_machine);
			// 亲和度满足
			if (deal_task.affinity_machines.count(deal_machine.id)) {
				break;
			}
		}
        
        // 记录执行开始后需要花费的时间(从读取依赖开始)
		int cost_time = 0;
		int machines_idx = machines_tmp.size() - 1;
		auto &deal_machine = machines_tmp[machines_idx];
		auto &deal_disk = disks[tasks_disk[id]];		
		int arrival_time = max({deal_machine.available_time, earliest_start_time[id]});
		deal_machine.available_time = arrival_time;
		cout << id << " " << arrival_time << " " << deal_machine.id << " " <<  deal_disk.id << "\n";
		cost_time += pre_cost[id];
        cost_time += up(deal_machine.power, deal_task.size_);
		cost_time += up(deal_disk.rate, deal_task.output_data_size);

		//使用的mahcine更新参数
		deal_machine.available_time += cost_time;
		
		//出队的machine重新入队
		for (auto m:machines_tmp){
			machines_pq.push(m);
		} 

		//释放依赖并为其依赖加上读取时间(若必要的话) 
		for (auto &son:sons[id]){
			dus[son.task_id] -= 1;
			
			//这个点可以优化 
			earliest_start_time[son.task_id] = max(earliest_start_time[son.task_id], arrival_time + cost_time);
			if (son.dependency_type == 0) {
				pre_cost[son.task_id] += up(deal_disk.rate, deal_task.output_data_size);
			}
			if (dus[son.task_id] == 0) {
                tasks[son.task_id].earliest_start_time = earliest_start_time[son.task_id];
				ready_tasks_pq.push(tasks[son.task_id]);
			}
		}
		
		
	}
	
}

int main() {
	
    
    cin >> l;
    vector<Task> tasks(l + 1);
    int id;
    // 读取任务信息
    for (int i = 1; i <= l; ++i) {
        int k;
        cin >> id;
        tasks[id].id = id;
        cin >> tasks[id].size_ >> tasks[id].output_data_size >> k;
        for (int j = 0; j < k; ++j) {
        	int x;
        	cin >> x;
            tasks[i].affinity_machines.insert(x);
        }
    }
    
    // 读取机器信息
    cin >> n;
    vector<Machine> machines(n + 1);
    
    for (int i = 1; i <= n; ++i) {
    	cin >> id;
    	machines[id].id = id;
        cin >> machines[id].power;
    }
    
    // 读取磁盘信息
    cin >> m;
    vector<Disk> disks(m + 1);
    
    for (int i = 1; i <= m; ++i) {
    	cin >> id;
    	disks[id].id = id;
        cin >> disks[i].rate >> disks[i].quota;
    }
    
    // 读取数据依赖信息
    cin >> N;
    vector<pair<int, int>> data_dependencies(N + 1);
    
    for (int i = 1; i <= N; ++i) {
        cin >> data_dependencies[i].first >> data_dependencies[i].second;
    }
    
    // 读取环境依赖信息
    cin >> M;
    vector<pair<int, int>> environment_dependencies(M + 1);
    
    for (int i = 1; i <= M; ++i) {
        cin >> environment_dependencies[i].first >> environment_dependencies[i].second;
    }

	work(tasks, machines, disks, data_dependencies, environment_dependencies);

    return 0;
}

```

### 解法八 2024/6/19

> 基于解法七
>
> 考虑Task的最近可以执行的时间
>
> 分数:193w 提升不明显

```c++
#include <bits/stdc++.h>

using namespace std;

int l, n, m, N, M;
// 定义任务结构体
struct Task {
    int id;
    int size_;
    int output_data_size;
    int earliest_start_time = 0;
    int free_cnt = 0;
    int total_pre_data = 0;
    set<int> affinity_machines;
};

//1. 开始时间早 2. 亲和机器多 3. 释放数量多
struct CompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
        if (p1.earliest_start_time == p2.earliest_start_time) {
            if (p1.affinity_machines.size() == p2.affinity_machines.size()){
                return p1.free_cnt < p2.free_cnt;
            }
            return p1.affinity_machines.size() < p2.affinity_machines.size();
        }
        return p1.earliest_start_time > p2.earliest_start_time;
    }
};


struct PreCompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
//    	if (p1.total_pre_data == p2.total_pre_data) {
//    		return p1.output_data_size > p2.output_data_size;
//		}
        return p1.total_pre_data < p2.total_pre_data;
    }
};
// 定义机器结构体
struct Machine {
    int id;
    int power;
    int available_time = 0; // 机器的可用时间初始化为0
};
struct CompareMachine {
    bool operator()(const Machine& p1, const Machine& p2) { 
		
		//优先处理能力 
		if (p1.power == p2.power){
            return p1.available_time > p2.available_time;
        }
        return p1.power < p2.power;  
		
		//优先最早空闲   
//		if (p1.available_time == p2.available_time){
//            return p1.power < p2.power;
//        }
//        return p1.available_time > p2.available_time;  
    }
};

// 定义磁盘结构体
struct Disk {
    int id;
    int rate;
    int quota;
    int used_quota = 0; // 磁盘的已用配额初始化为0
};

struct CompareDisk {
    bool operator()(const Disk& p1, const Disk& p2) { 
       
        if (p1.rate == p2.rate) {
        	return p1.quota - p1.used_quota < p2.quota - p2.used_quota;
		}
		return p1.rate < p2.rate;
        
    }
};


// 定义依赖关系结构体
struct Dependency {
    int task_id;
    int dependency_type; // 0表示数据依赖，1表示环境依赖
};

// b / a 上取整
int up(int a, int b) {
	return (a + b - 1 ) / a;
}

void debug(vector<int> &pre_cost, vector<int> &earliest_start_time) {
    for (int i = 1; i <= l; i ++){
        cout << i << "' cost:" << pre_cost[i] << "\n"; 
    }
    for (int i = 1; i <= l; i ++){
        cout << i << "' e_s_t:" << earliest_start_time[i] << "\n"; 
    }
}
// 计算任务的开始时间
void work(vector<Task>& tasks, vector<Machine>& machines, vector<Disk>& disks, vector<pair<int, int>>& data_dependencies, vector<pair<int, int>>& environment_dependencies) {
    //tuple<int, int, int, int> result;
    vector<vector<Dependency>> ps(l + 1, vector<Dependency>(0)); // 记录每个任务的被依赖父节点 
    vector<vector<Dependency>> sons(l + 1, vector<Dependency>(0)); // 记录每个任务的依赖子节点
    priority_queue<Task, vector<Task>, CompareTask> ready_tasks_pq; // 当前至少有一个Machine可以处理的就绪任务队列
	priority_queue<Task, vector<Task>, PreCompareTask> pre_tasks_pq; // 预分配每个Task对应的Disk 
	priority_queue<Machine, vector<Machine>, CompareMachine> machines_pq; //Machine优先队列
    priority_queue<Disk, vector<Disk>, CompareDisk> disks_pq_fixed;	//Disk固定优先队列
    unordered_map<int, int> tasks_disk;// 重要Task的固定Disk 每个测试样例动态分配
	vector<int> dus(l + 1, 0); //记录每个节点的读书来判断是否可以入队
	vector<int> pre_cost(l + 1, 0); // 记录每个任务需要预处理的时间 
    
	vector<int> earliest_start_time(l + 1, 0); // 记录每个任务至少在哪个时间点开始
	vector<int> cpu_earliest_start_time(l + 1, 0); // 记录每个任务至少在哪个时间点开始
	for (auto& item:data_dependencies){
    	ps[item.second].push_back({item.first, 0}); 
    	sons[item.first].push_back({item.second, 0});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
        tasks[item.first].total_pre_data += tasks[item.first].output_data_size;
        
	}
	
	for (auto& item:environment_dependencies){
    	ps[item.second].push_back({item.first, 1});
    	sons[item.first].push_back({item.second, 1});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	//初始化就绪任务 
	for (int i = 1; i <= l; i ++){
		if (dus[i] == 0) {
			dus[i] = -1;
			ready_tasks_pq.push(tasks[i]);
		}
		pre_tasks_pq.push(tasks[i]);
	}
	//初始化机器优先队列 
	for (int i = 1;i <= n; i ++){
		machines_pq.push(machines[i]);
	}
	
    //初始化硬盘固定优先队列 
	for (int i = 1;i <= m; i ++){
		disks_pq_fixed.push(disks[i]);
	}
    
    //动态分配Task为固定的Disk
    while (! pre_tasks_pq.empty()) {
    	auto deal_task = pre_tasks_pq.top();
    	pre_tasks_pq.pop();
        int id = deal_task.id;
        int data = deal_task.output_data_size;
        vector<Disk> disks_tmp;
        while (! disks_pq_fixed.empty()){
            auto deal_disk = disks_pq_fixed.top();
            disks_pq_fixed.pop();
            //剩余额度满足
            if  (deal_disk.quota - deal_disk.used_quota >= data) {
                deal_disk.used_quota += data;
                disks[deal_disk.id].used_quota += data;
                disks_pq_fixed.push(deal_disk);
                tasks_disk[id] = deal_disk.id;
                break;
            }
            disks_tmp.push_back(deal_disk);
		}
        for (auto tt: disks_tmp) {
            disks_pq_fixed.push(tt);
        }
        
    }
    
	while (!ready_tasks_pq.empty()){
//        debug(pre_cost, earliest_start_time);
		auto deal_task = ready_tasks_pq.top();
		ready_tasks_pq.pop();
		int id = deal_task.id; 
		vector<Machine> machines_tmp;
		
		// 
		while (! machines_pq.empty()){
			auto deal_machine = machines_pq.top();
			machines_pq.pop();
			machines_tmp.push_back(deal_machine);
			// 亲和度满足
			if (deal_task.affinity_machines.count(deal_machine.id)) {
				break;
			}
		}
        
        // 记录执行开始后需要花费的时间(从读取依赖开始)
		int cpu_cost_time = 0, cost_time = 0;
		int machines_idx = machines_tmp.size() - 1;
		auto &deal_machine = machines_tmp[machines_idx];
		auto &deal_disk = disks[tasks_disk[id]];		
		int arrival_time = max({deal_machine.available_time, deal_task.earliest_start_time});
		deal_machine.available_time = arrival_time;
		cout << id << " " << arrival_time << " " << deal_machine.id << " " <<  deal_disk.id << "\n";
		cost_time += pre_cost[id];
		cpu_cost_time += pre_cost[id];
        cost_time += up(deal_machine.power, deal_task.size_);
		cpu_cost_time += up(deal_machine.power, deal_task.size_);
		cost_time += up(deal_disk.rate, deal_task.output_data_size);

		//使用的mahcine更新参数
		deal_machine.available_time += cost_time;
		
		//出队的machine重新入队
		for (auto m:machines_tmp){
			machines_pq.push(m);
		} 

		//释放依赖并为其依赖加上读取时间(若必要的话) 
		for (auto &son:sons[id]){
			dus[son.task_id] -= 1;
			
			//数据依赖 
			if (son.dependency_type == 0) {
				pre_cost[son.task_id] += up(deal_disk.rate, deal_task.output_data_size);
				earliest_start_time[son.task_id] = max(earliest_start_time[son.task_id], arrival_time + cost_time);
			}
			//环境依赖 
			else {
				cpu_earliest_start_time[son.task_id] = max(cpu_earliest_start_time[son.task_id], 
				arrival_time + cpu_cost_time);
			}
			if (dus[son.task_id] == 0) {
                tasks[son.task_id].earliest_start_time = max(earliest_start_time[son.task_id], 
                cpu_earliest_start_time[son.task_id]);
				ready_tasks_pq.push(tasks[son.task_id]);
			}
		}
		
		
	}
	
}

int main() {
	
    
    cin >> l;
    vector<Task> tasks(l + 1);
    int id;
    // 读取任务信息
    for (int i = 1; i <= l; ++i) {
        int k;
        cin >> id;
        tasks[id].id = id;
        cin >> tasks[id].size_ >> tasks[id].output_data_size >> k;
        for (int j = 0; j < k; ++j) {
        	int x;
        	cin >> x;
            tasks[i].affinity_machines.insert(x);
        }
    }
    
    // 读取机器信息
    cin >> n;
    vector<Machine> machines(n + 1);
    
    for (int i = 1; i <= n; ++i) {
    	cin >> id;
    	machines[id].id = id;
        cin >> machines[id].power;
    }
    
    // 读取磁盘信息
    cin >> m;
    vector<Disk> disks(m + 1);
    
    for (int i = 1; i <= m; ++i) {
    	cin >> id;
    	disks[id].id = id;
        cin >> disks[i].rate >> disks[i].quota;
    }
    
    // 读取数据依赖信息
    cin >> N;
    vector<pair<int, int>> data_dependencies(N + 1);
    
    for (int i = 1; i <= N; ++i) {
        cin >> data_dependencies[i].first >> data_dependencies[i].second;
    }
    
    // 读取环境依赖信息
    cin >> M;
    vector<pair<int, int>> environment_dependencies(M + 1);
    
    for (int i = 1; i <= M; ++i) {
        cin >> environment_dependencies[i].first >> environment_dependencies[i].second;
    }

	work(tasks, machines, disks, data_dependencies, environment_dependencies);

    return 0;
}

```

### 解法九 2024/6/19

> 优化点：
>
> 1. Machine选择结束执行时间最短的,这样的话程序的时间复杂度比较高  (目前n*l 不超过1个亿)
> 2. Task队列的优先级优化 优先2 size_大
> 3. 预分配Task优先 2output_size 大的
> 4. Disk队列优先2 left_quota小

> 分数:244w+

```c++
#include <bits/stdc++.h>

using namespace std;

int l, n, m, N, M;
// 定义任务结构体
struct Task {
    int id;
    int size_;
    int output_data_size;
    int earliest_start_time = 0;
    int free_cnt = 0;
    int total_pre_data = 0;
    set<int> affinity_machines;
};

//1. 开始时间早 2. size_ 大 3.释放数量多 4. 亲和机器多 
struct CompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
        if (p1.earliest_start_time == p2.earliest_start_time) {
            if (p1.size_ == p2.size_) {
                if (p1.free_cnt == p2.free_cnt){
                    return p1.affinity_machines.size() < p2.affinity_machines.size();
                }
                return p1.free_cnt == p2.free_cnt;
            }
            return p1.size_ < p2.size_;
        }
        return p1.earliest_start_time > p2.earliest_start_time;
    }
};

struct PreCompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
    	if (p1.total_pre_data == p2.total_pre_data) {
    		return p1.output_data_size < p2.output_data_size;
		}
        return p1.total_pre_data < p2.total_pre_data;
    }
};
// 定义机器结构体
struct Machine {
    int id;
    int power;
    int available_time = 0; // 机器的可用时间初始化为0
};
struct CompareMachine {
    bool operator()(const Machine& p1, const Machine& p2) { 
		
		//优先处理能力 
		if (p1.power == p2.power){
            return p1.available_time > p2.available_time;
        }
        return p1.power < p2.power;  
		
		//优先最早空闲   
//		if (p1.available_time == p2.available_time){
//            return p1.power < p2.power;
//        }
//        return p1.available_time > p2.available_time;  
    }
};

// 定义磁盘结构体
struct Disk {
    int id;
    int rate;
    int quota;
    int used_quota = 0; // 磁盘的已用配额初始化为0
};

struct CompareDisk {
    bool operator()(const Disk& p1, const Disk& p2) { 
       
        if (p1.rate == p2.rate) {
        	return p1.quota - p1.used_quota > p2.quota - p2.used_quota;
		}
		return p1.rate < p2.rate;
        
    }
};


// 定义依赖关系结构体
struct Dependency {
    int task_id;
    int dependency_type; // 0表示数据依赖，1表示环境依赖
};

// b / a 上取整
int up(int a, int b) {
	return (a + b - 1 ) / a;
}

void debug(vector<int> &pre_cost, vector<int> &earliest_start_time) {
    for (int i = 1; i <= l; i ++){
        cout << i << "' cost:" << pre_cost[i] << "\n"; 
    }
    for (int i = 1; i <= l; i ++){
        cout << i << "' e_s_t:" << earliest_start_time[i] << "\n"; 
    }
}
// 计算任务的开始时间
void work(vector<Task>& tasks, vector<Machine>& machines, vector<Disk>& disks, vector<pair<int, int>>& data_dependencies, vector<pair<int, int>>& environment_dependencies) {
    //tuple<int, int, int, int> result;
    vector<vector<Dependency>> ps(l + 1, vector<Dependency>(0)); // 记录每个任务的被依赖父节点 
    vector<vector<Dependency>> sons(l + 1, vector<Dependency>(0)); // 记录每个任务的依赖子节点
    priority_queue<Task, vector<Task>, CompareTask> ready_tasks_pq; // 当前至少有一个Machine可以处理的就绪任务队列
	priority_queue<Task, vector<Task>, PreCompareTask> pre_tasks_pq; // 预分配每个Task对应的Disk 
    priority_queue<Disk, vector<Disk>, CompareDisk> disks_pq_fixed;	//Disk固定优先队列
    unordered_map<int, int> tasks_disk;// 重要Task的固定Disk 每个测试样例动态分配
	vector<int> dus(l + 1, 0); //记录每个节点的读书来判断是否可以入队
	vector<int> pre_cost(l + 1, 0); // 记录每个任务需要预处理的时间 
    
	vector<int> earliest_start_time(l + 1, 0); // 记录每个任务至少在哪个时间点开始
	vector<int> cpu_earliest_start_time(l + 1, 0); // 记录每个任务至少在哪个时间点开始
	for (auto& item:data_dependencies){
    	ps[item.second].push_back({item.first, 0}); 
    	sons[item.first].push_back({item.second, 0});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
        tasks[item.first].total_pre_data += tasks[item.first].output_data_size;
        
	}
	
	for (auto& item:environment_dependencies){
    	ps[item.second].push_back({item.first, 1});
    	sons[item.first].push_back({item.second, 1});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	//初始化就绪任务 
	for (int i = 1; i <= l; i ++){
		if (dus[i] == 0) {
			dus[i] = -1;
			ready_tasks_pq.push(tasks[i]);
		}
		pre_tasks_pq.push(tasks[i]);
	}
	
    //初始化硬盘固定优先队列 
	for (int i = 1;i <= m; i ++){
		disks_pq_fixed.push(disks[i]);
	}
    
    //动态分配Task为固定的Disk
    while (! pre_tasks_pq.empty()) {
    	auto deal_task = pre_tasks_pq.top();
    	pre_tasks_pq.pop();
        int id = deal_task.id;
        int data = deal_task.output_data_size;
        vector<Disk> disks_tmp;
        while (! disks_pq_fixed.empty()){
            auto deal_disk = disks_pq_fixed.top();
            disks_pq_fixed.pop();
            //剩余额度满足
            if  (deal_disk.quota - deal_disk.used_quota >= data) {
                deal_disk.used_quota += data;
                disks[deal_disk.id].used_quota += data;
                disks_pq_fixed.push(deal_disk);
                tasks_disk[id] = deal_disk.id;
                break;
            }
            disks_tmp.push_back(deal_disk);
		}
        for (auto tt: disks_tmp) {
            disks_pq_fixed.push(tt);
        }
        
    }
    
	while (!ready_tasks_pq.empty()){
//        debug(pre_cost, earliest_start_time);
		auto deal_task = ready_tasks_pq.top();
		ready_tasks_pq.pop();
		int id = deal_task.id; 
		
		pair<int, int> earliest_over_time = {0x3f3f3f3f, 0};
        
        //安排机器
        for (int i = 1; i <= n; i ++) {
            auto deal_machine = machines[i];
            int arrival_time = max({deal_machine.available_time, deal_task.earliest_start_time});
            int over_time = up(deal_machine.power, deal_task.size_) + arrival_time;
            //亲和度要满足 
            if (over_time < earliest_over_time.first && deal_task.affinity_machines.count(i)){
                earliest_over_time = {over_time, i};
            }
        }
        
        // 记录执行开始后需要花费的时间(从读取依赖开始)
		int cpu_cost_time = 0, cost_time = 0;
        int machines_idx = earliest_over_time.second;
		auto &deal_machine = machines[machines_idx];
		auto &deal_disk = disks[tasks_disk[id]];		
		int arrival_time = max({deal_machine.available_time, deal_task.earliest_start_time});
		deal_machine.available_time = arrival_time;
		cout << id << " " << arrival_time << " " << deal_machine.id << " " <<  deal_disk.id << "\n";
		cost_time += pre_cost[id];
		cpu_cost_time += pre_cost[id];
        cost_time += up(deal_machine.power, deal_task.size_);
		cpu_cost_time += up(deal_machine.power, deal_task.size_);
		cost_time += up(deal_disk.rate, deal_task.output_data_size);

		//使用的mahcine更新参数
		deal_machine.available_time += cost_time;
		

		//释放依赖并为其依赖加上读取时间(若必要的话) 
		for (auto &son:sons[id]){
			dus[son.task_id] -= 1;
			
			//数据依赖 
			if (son.dependency_type == 0) {
				pre_cost[son.task_id] += up(deal_disk.rate, deal_task.output_data_size);
				earliest_start_time[son.task_id] = max(earliest_start_time[son.task_id], arrival_time + cost_time);
			}
			//环境依赖 
			else {
				cpu_earliest_start_time[son.task_id] = max(cpu_earliest_start_time[son.task_id], 
				arrival_time + cpu_cost_time);
			}
			if (dus[son.task_id] == 0) {
                tasks[son.task_id].earliest_start_time = max(earliest_start_time[son.task_id], 
                cpu_earliest_start_time[son.task_id]);
				ready_tasks_pq.push(tasks[son.task_id]);
			}
		}
		
		
	}
	
}

int main() {
	
    
    cin >> l;
    vector<Task> tasks(l + 1);
    int id;
    // 读取任务信息
    for (int i = 1; i <= l; ++i) {
        int k;
        cin >> id;
        tasks[id].id = id;
        cin >> tasks[id].size_ >> tasks[id].output_data_size >> k;
        for (int j = 0; j < k; ++j) {
        	int x;
        	cin >> x;
            tasks[i].affinity_machines.insert(x);
        }
    }
    
    // 读取机器信息
    cin >> n;
    vector<Machine> machines(n + 1);
    
    for (int i = 1; i <= n; ++i) {
    	cin >> id;
    	machines[id].id = id;
        cin >> machines[id].power;
    }
    
    // 读取磁盘信息
    cin >> m;
    vector<Disk> disks(m + 1);
    
    for (int i = 1; i <= m; ++i) {
    	cin >> id;
    	disks[id].id = id;
        cin >> disks[i].rate >> disks[i].quota;
    }
    // 读取数据依赖信息
    cin >> N;
    vector<pair<int, int>> data_dependencies(N + 1);
    
    for (int i = 1; i <= N; ++i) {
        cin >> data_dependencies[i].first >> data_dependencies[i].second;
    }
    
    // 读取环境依赖信息
    cin >> M;
    vector<pair<int, int>> environment_dependencies(M + 1);
    
    for (int i = 1; i <= M; ++i) {
        cin >> environment_dependencies[i].first >> environment_dependencies[i].second;
    }

	work(tasks, machines, disks, data_dependencies, environment_dependencies);

    return 0;
}

```

### 解法十 2024/6/20

> 基于解法九 优化每个Task的固定Disk，total_output - k * output_size
>
> 分数下降一点点

```c++
#include <bits/stdc++.h>

using namespace std;

int l, n, m, N, M, k = 0, max_k = 0;
// 定义任务结构体
struct Task {
    int id;
    int size_;
    int output_data_size;
    int earliest_start_time = 0;
    int free_cnt = 0;
    int total_pre_data = 0;
    set<int> affinity_machines;
};

//1. 开始时间早 2. size_ 大 3.亲和机器多 4. 释放数量多
struct CompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
        if (p1.earliest_start_time == p2.earliest_start_time) {
            if (p1.size_ == p2.size_) {
                if (p1.affinity_machines.size() == p2.affinity_machines.size()){
                    return p1.free_cnt < p2.free_cnt;
                }
                return p1.affinity_machines.size() < p2.affinity_machines.size();
            }
            return p1.size_ < p2.size_;
        }
        return p1.earliest_start_time > p2.earliest_start_time;
    }
    
};

struct PreCompareTask {
    bool operator()(const Task& p1, const Task& p2) { 
//    	if (p1.total_pre_data == p2.total_pre_data) {
//    		return p1.output_data_size < p2.output_data_size;
//		}
        return p1.total_pre_data - k * p1.output_data_size < p2.total_pre_data - k * p2.output_data_size;
    }
};
// 定义机器结构体
struct Machine {
    int id;
    int power;
    int available_time = 0; // 机器的可用时间初始化为0
};
struct CompareMachine {
    bool operator()(const Machine& p1, const Machine& p2) { 
		
		//优先处理能力 
		if (p1.power == p2.power){
            return p1.available_time > p2.available_time;
        }
        return p1.power < p2.power;  
		
		//优先最早空闲   
//		if (p1.available_time == p2.available_time){
//            return p1.power < p2.power;
//        }
//        return p1.available_time > p2.available_time;  
    }
};

// 定义磁盘结构体
struct Disk {
    int id;
    int rate;
    int quota;
    int used_quota = 0; // 磁盘的已用配额初始化为0
};

struct CompareDisk {
    bool operator()(const Disk& p1, const Disk& p2) { 
       
        if (p1.rate == p2.rate) {
        	return p1.quota - p1.used_quota < p2.quota - p2.used_quota;
		}
		return p1.rate < p2.rate;
        
    }
};


// 定义依赖关系结构体
struct Dependency {
    int task_id;
    int dependency_type; // 0表示数据依赖，1表示环境依赖
};

// b / a 上取整
int up(int a, int b) {
	return (a + b - 1 ) / a;
}

void debug(vector<int> &pre_cost, vector<int> &earliest_start_time) {
    for (int i = 1; i <= l; i ++){
        cout << i << "' cost:" << pre_cost[i] << "\n"; 
    }
    for (int i = 1; i <= l; i ++){
        cout << i << "' e_s_t:" << earliest_start_time[i] << "\n"; 
    }
}
// 计算任务的开始时间
void work(vector<Task>& tasks, vector<Machine>& machines, vector<Disk>& disks, vector<pair<int, int>>& data_dependencies, vector<pair<int, int>>& environment_dependencies) {
    //tuple<int, int, int, int> result;
    vector<vector<Dependency>> ps(l + 1, vector<Dependency>(0)); // 记录每个任务的被依赖父节点 
    vector<vector<Dependency>> sons(l + 1, vector<Dependency>(0)); // 记录每个任务的依赖子节点
    priority_queue<Task, vector<Task>, CompareTask> ready_tasks_pq; // 当前至少有一个Machine可以处理的就绪任务队列
    priority_queue<Disk, vector<Disk>, CompareDisk> disks_pq_fixed;	//Disk固定优先队列
    unordered_map<int, int> tasks_disk;// 重要Task的固定Disk 每个测试样例动态分配
	vector<int> dus(l + 1, 0); //记录每个节点的读书来判断是否可以入队
	vector<int> pre_cost(l + 1, 0); // 记录每个任务需要预处理的时间 
    
	vector<int> earliest_start_time(l + 1, 0); // 记录每个任务至少在哪个时间点开始
	vector<int> cpu_earliest_start_time(l + 1, 0); // 记录每个任务至少在哪个时间点开始
	for (auto& item:data_dependencies){
    	ps[item.second].push_back({item.first, 0}); 
    	sons[item.first].push_back({item.second, 0});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
        tasks[item.first].total_pre_data += tasks[item.first].output_data_size;
        max_k = max(max_k, int(sons[item.first].size()));
        
	}
	
	for (auto& item:environment_dependencies){
    	ps[item.second].push_back({item.first, 1});
    	sons[item.first].push_back({item.second, 1});
    	tasks[item.first].free_cnt += 1;
    	dus[item.second] += 1;
	}
	//初始化就绪任务 
	for (int i = 1; i <= l; i ++){
		if (dus[i] == 0) {
			dus[i] = -1;
			ready_tasks_pq.push(tasks[i]);
		}
	}
	
    //初始化硬盘固定优先队列 
	for (int i = 1;i <= m; i ++){
		disks_pq_fixed.push(disks[i]);
	}
    
    int min_loss = INT_MAX, fixed_k = 0;
    //确定一个动态因子 k来 为Disk分配权重 
    for (int i = 0; i <= max_k; i ++){
    	int loss = 0;
    	k = i;
    	priority_queue<Task, vector<Task>, PreCompareTask> pre_tasks_pq_tmp;
    	//初始化就绪任务 
		for (int i = 1; i <= l; i ++){
			pre_tasks_pq_tmp.push(tasks[i]);
		}
    	priority_queue<Disk, vector<Disk>, CompareDisk> disks_pq_fixed_tmp = disks_pq_fixed;
    	unordered_map<int, int> tasks_disk_tmp;

	    //动态分配Task为固定的Disk
	    while (! pre_tasks_pq_tmp.empty()) {
	    	auto deal_task = pre_tasks_pq_tmp.top();
	    	pre_tasks_pq_tmp.pop();
	        int id = deal_task.id;
	        int data = deal_task.output_data_size;
	        vector<Disk> disks_tmp;
	        
	        while (! disks_pq_fixed_tmp.empty()){
	            auto deal_disk = disks_pq_fixed_tmp.top();
	            disks_pq_fixed_tmp.pop();
	            //剩余额度满足
	            if  (deal_disk.quota - deal_disk.used_quota >= data) {
	                deal_disk.used_quota += data;
	                disks[deal_disk.id].used_quota += data;
	                disks_pq_fixed_tmp.push(deal_disk);
	                loss += up(deal_disk.rate, deal_task.free_cnt * deal_task.output_data_size);
	                tasks_disk_tmp[id] = deal_disk.id;
	                break;
	            }
	            disks_tmp.push_back(deal_disk);
			}
	        for (auto tt: disks_tmp) {
	            disks_pq_fixed_tmp.push(tt);
	        }
	        
	    }
	    if (loss < min_loss) {
	    	fixed_k = i;
	    	min_loss = loss;
	    	tasks_disk = tasks_disk_tmp;
		}
	} 
	
	while (!ready_tasks_pq.empty()){
//        debug(pre_cost, earliest_start_time);
		auto deal_task = ready_tasks_pq.top();
		ready_tasks_pq.pop();
		int id = deal_task.id; 
		
		pair<int, int> earliest_over_time = {0x3f3f3f3f, 0};
        
        //安排机器
        for (int i = 1; i <= n; i ++) {
            auto deal_machine = machines[i];
            int arrival_time = max({deal_machine.available_time, deal_task.earliest_start_time});
            int over_time = up(deal_machine.power, deal_task.size_) + arrival_time;
            //亲和度要满足 
            if (over_time < earliest_over_time.first && deal_task.affinity_machines.count(i)){
                earliest_over_time = {over_time, i};
            }
        }
        
        // 记录执行开始后需要花费的时间(从读取依赖开始)
		int cpu_cost_time = 0, cost_time = 0;
        int machines_idx = earliest_over_time.second;
		auto &deal_machine = machines[machines_idx];
		auto &deal_disk = disks[tasks_disk[id]];		
		int arrival_time = max({deal_machine.available_time, deal_task.earliest_start_time});
		deal_machine.available_time = arrival_time;
		cout << id << " " << arrival_time << " " << deal_machine.id << " " <<  deal_disk.id << "\n";
		cost_time += pre_cost[id];
		cpu_cost_time += pre_cost[id];
        cost_time += up(deal_machine.power, deal_task.size_);
		cpu_cost_time += up(deal_machine.power, deal_task.size_);
		cost_time += up(deal_disk.rate, deal_task.output_data_size);

		//使用的mahcine更新参数
		deal_machine.available_time += cost_time;
		

		//释放依赖并为其依赖加上读取时间(若必要的话) 
		for (auto &son:sons[id]){
			dus[son.task_id] -= 1;
			
			//数据依赖 
			if (son.dependency_type == 0) {
				pre_cost[son.task_id] += up(deal_disk.rate, deal_task.output_data_size);
				earliest_start_time[son.task_id] = max(earliest_start_time[son.task_id], arrival_time + cost_time);
			}
			//环境依赖 
			else {
				cpu_earliest_start_time[son.task_id] = max(cpu_earliest_start_time[son.task_id], 
				arrival_time + cpu_cost_time);
			}
			if (dus[son.task_id] == 0) {
                tasks[son.task_id].earliest_start_time = max(earliest_start_time[son.task_id], 
                cpu_earliest_start_time[son.task_id]);
				ready_tasks_pq.push(tasks[son.task_id]);
			}
		}
		
		
	}
	
}

int main() {
	
    
    cin >> l;
    vector<Task> tasks(l + 1);
    int id;
    // 读取任务信息
    for (int i = 1; i <= l; ++i) {
        int k;
        cin >> id;
        tasks[id].id = id;
        cin >> tasks[id].size_ >> tasks[id].output_data_size >> k;
        for (int j = 0; j < k; ++j) {
        	int x;
        	cin >> x;
            tasks[i].affinity_machines.insert(x);
        }
    }
    
    
    // 读取机器信息
    cin >> n;
    vector<Machine> machines(n + 1);
    
    for (int i = 1; i <= n; ++i) {
    	cin >> id;
    	machines[id].id = id;
        cin >> machines[id].power;
    }
    // 读取磁盘信息
    cin >> m;
    vector<Disk> disks(m + 1);
    
    for (int i = 1; i <= m; ++i) {
    	cin >> id;
    	disks[id].id = id;
        cin >> disks[i].rate >> disks[i].quota;
    }
    // 读取数据依赖信息
    cin >> N;
    vector<pair<int, int>> data_dependencies(N + 1);
    
    for (int i = 1; i <= N; ++i) {
        cin >> data_dependencies[i].first >> data_dependencies[i].second;
    }
    
    // 读取环境依赖信息
    cin >> M;
    vector<pair<int, int>> environment_dependencies(M + 1);
    
    for (int i = 1; i <= M; ++i) {
        cin >> environment_dependencies[i].first >> environment_dependencies[i].second;
    }

	work(tasks, machines, disks, data_dependencies, environment_dependencies);

    return 0;
}

```

